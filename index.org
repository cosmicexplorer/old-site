#+STARTUP: showeverything
#+TITLE: passion paradise
#+AUTHOR: Danny McClanahan
#+EMAIL: (format "%s@%s.com" "danieldmcclanahan" "gmail")

Press the =?= key to see movement and usage commands.

* about this site

This site was generated by [[about me][me]] from static files using [[https://gnu.org/software/emacs][emacs]] and [[http://orgmode.org][org-mode]] (you can see the org source by clicking the "See Org Source" button below). The [[https://github.com/cosmicexplorer/org-site-creator][generator]] is by no means production quality code, but it works pretty reliably and doesn't harvest your personal information (probably). The site supports org-mode's linking features (here's [[file:test.c]] from this repo), as well as org-babel; here's some inline code:
#+BEGIN_SRC javascript
console.log("hello world!");

var a = 3; // set a to 3

var f = function(){
  this.x = a;
}

var g = new f;
#+END_SRC

The highlighting of code blocks runs off [[https://highlightjs.org][highlight.js]]. It's interesting to note that all these interconnected pages are actually a single page! Such is the magic of [[https://github.com/cosmicexplorer/org-info-js][org-info.js]] (which I've sprinkled a little extra pizazz on).

Since the site generation is totally static (the generated site doesn't rely on external resources), I'd like to try making it a more generic sort of local documentation generator. But that'll come after I write code that people want documentation for.

** about me

I'm Danny McClanahan. I [[https://github.com/cosmicexplorer][write code]] and [[posts][occasionally scribble on the internet]]. I'm an undergraduate at Vanderbilt University and most of my friends think I'm cool; feel free to disagree.

* posts

I often find that writing about things is harder for me to do than to actually do them, so this is an attempt to combat that. To search through all posts, you can either [[https://github.com/cosmicexplorer/cosmicexplorer.github.io][clone this repo]] or press the =o= key to run occur mode. You can always use your browser's text search tool to search the current post.

** first thoughts on haskell

<2015-08-13>

I don't know haskell, so I'm sailing through [[http://learnyouahaskell.com][learn you a haskell for great good]] (which is fantastic) at a pretty good clip and eventually writing a [[https://github.com/cosmicexplorer/haskshell][basic shell interpreter]]. I had a few thoughts so I decided to write them down.

- Idiomatic haskell relies on many extremely small, simple, composable functions. On the one hand, this is a good programming practice for most programming languages. On the other hand, this is largely because, unlike lisp, haskell's clean-looking whitespace-heavy syntax makes it extremely difficult to compose functions of any size without extreme application of syntactic sugar (which also makes it much harder to parse).
- Haskell is super hard to parse in your head. The emacs support is fantastic, with extremely rich syntax highlighting; however, I think it would be extremely difficult to parse the syntax in your head without the syntax highlighting. Simpler syntaxes like javascript and lisp can be written without a ton of syntax highlighting extremely easily, and I think haskell by nature is tougher to reason about.
- Curried functions are a cool idea and a great, useful instance of syntactic sugar. Haskell's emphasis on recursion forces most functions into a simple calling style (higher-order/callback function last), which means it's likely the order of the arguments will be correct for currying. However, the syntactic sugar breaks down when the arguments to a function must be switched around; "currying" (which is just a fancy word for making an anonymous function really easily) requires manually making a lambda like lisp or javascript.
- Pattern matching is really great. It:
  1. makes a decision tree based on the structure of one or more arguments
  2. assigns values to temporary variables used in a statement
  3. returns a value
  4. does this with an extremely minimal amount of syntax.
- I think a good reader macro could accomplish a similar thing as pattern-matching in lisp. ~destructuring-bind~ is disgustingly verbose and doesn't perform switching. I don't think currying could be implemented as easily, though, outside of a lambda convenience macro.
- Could some forms of pattern matching be performed at compile-time? I suspect not, but I don't like the idea of branching on a pattern match in every iteration of a tight loop, even with tail-recursion.
- Making a language lazy by default in every possible computation is a fantastic idea. I'm not sure I see where it really takes effect yet outside of list recursion (which many other languages (C#, js) have already implemented), but it seems cool.
- I tried to understand haskell about a year ago (which was about a year after I started programming) and found it hopelessly confusing. After a year of emacs (with some common lisp here and there), I find it extremely easy to understand most of this tutorial, even the "more complex" functional programming parts.
- ghc's error messages are understandable after a bit of practice but unnecessarily cryptic. If it's more useful for compiler writers to have more precise error messages, then they should have a special switch that turns on raw core dumps instead of errors and give regular users some more help.
- If you have to use types in a high-level language (hint: you don't, although haskell does a pretty good job), you need type inference. I didn't believe this before learning haskell, but it would be absolutely impossible to write code without it.
- A lot of the workarounds haskell uses to implement syntactic sugar start showing themselves pretty fast. In particular, moving back and forth between infix and prefix operators and functions requires gross extra punctuation and makes it difficult to quickly scan and reason about code. Obviously it's a learned habit, but there's definitely an efficiency loss to reading code because of that, especially as I find myself constantly turned to and fro between left- and right-associativity.
- Requiring the propagation of nulls through ~Maybe~ to all new computations is a simple and fantastic idea. It moves nullity from being a thing that can just "happen" to a well-understood phenomenon that can be extremely easily controlled, and removed when required. Splitting programs into imperative and non-imperative portions is a very simple analogy; at no point does stateful/imperative/IO/nondeterministic behavior creep into the "pure" process of computation (outside of random number generators). This is very much at odds with almost any other language where basic things like timing errors can require complex error handling. It's extremely easy to see how these concepts arose from an attempt to modernize program correctness proofs (although it's worth noting haskell only makes proving a program's running time /more/ complex).
- The analogy between async computation in javascript/node.js and haskell's ~IO~ impurity propagation is extremely strong. There's no way to get back to synchronous computation in javascript once you've (hacker voice) /gone async/ (at least, until continuations are implemented), and you have to continue using asynchronous callbacks to continue processing (although like haskell, syntactic sugar exists for async computation through ES7's async/await keywords and similar efforts). In addition, node.js streams perform the same function as lazy haskell lists, although node streams, to support multiple consumers transparently, are "pushed from behind" instead of "pulled from in front" as haskell's are. While this makes stopping stream input an explicit action instead of implicit the way lazy streams require, it also makes node streams easily able to support both sync and async sources without requiring any special help at all. Having this analogy makes it easier for me to understand the "boxing" and "unboxing" of computation into haskell's IO typeclass in terms of async computations. In fact, all IO in haskell could actually be implemented asynchronously under the hood with no one the wiser, precisely because of the separation between IO- and non IO-bound computation (or rather, computation and IO).
- Not requiring types to declare the functions that act on them creates a very duck-typed feel, which is extremely strange (and extremely welcome) in a statically-typed language. It's extremely reminiscent of lisp/js/ruby's approach where classes can be "opened up" after creation.
- Applicative functors and the like make chaining multiple IO operations (as well as other functor-like operations) extremely easy, syntax-wise (although learning all the syntax and jargon is most certainly not easy). While the pure/impure split remains, it seems to opaquely mix the two in uncertain ways, making it very easy to be confused about what is happening where. This seems to counteract the goal of separating computation from I/O, although the type system does most of the work to keep that separation anyway.

As a final thought, most of the documentation on any part of haskell becomes extremely dense, extremely fast. Learn You A Haskell was extremely helpful as an introduction, but the wealth of completely new jargon and programming paradigms required to effectively program in haskell makes it difficult to get up to speed with. The entire section on applicative functors is still hazy to me, and I've never had any such difficulty learning other languages. I'm not sure this can really be solved, since its strength is that it wraps so many complex operations and academic successes in syntax sugar to present extremely readable code (to those who can read it).

We'll see how easily this [[https://github.com/cosmicexplorer/haskshell][shell interpreter]] comes to fruition. I'm extremely impressed that a language can fit so many completely novel (to me, at least) constructs in a single package and keep it as streamlined as haskell does. I've finally managed to integrate a haskell environment into my emacs config, so I expect somewhat smooth sailing.

Anchor up?!
