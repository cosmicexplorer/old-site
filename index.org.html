<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.47 in css mode. -->
<html>
  <head>
  <style type="text/css">
    <!--
      pre > code {
        white-space: -moz-pre-wrap; /* Mozilla */
        white-space: -hp-pre-wrap; /* HP printers */
        white-space: -o-pre-wrap; /* Opera 7 */
        white-space: -pre-wrap; /* Opera 4-6 */
        white-space: pre-wrap; /* CSS 2.1 */
      }
    -->
  </style>

    <title>index.org</title>
    <style type="text/css">
    <!--
      body {
        color: #00ff00;
        background-color: #000000;
      }
      .ATTRLIST {
        /* (:foreground "yellow") */
        color: #ffff00;
      }
      .ATTRLIST-1 {
        /* (:foreground "tomato") */
        color: #ff6347;
      }
      .ATTRLIST-2 {
        /* (:foreground "magenta") */
        color: #ff00ff;
      }
      .ATTRLIST-3 {
        /* (:foreground "chocolate" :background "light goldenrod") */
        color: #d2691e;
        background-color: #eedd82;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ffffff;
        background-color: #8b008b;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #ffffff;
        background-color: #8b008b;
      }
      .constant {
        /* font-lock-constant-face */
        color: #7fffd4;
      }
      .italic {
        /* italic */
        color: #ff1493;
        font-style: italic;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        color: #5555ee;
        background-color: #333333;
        text-decoration: underline;
      }
      .org-block-end-line {
        /* org-block-end-line */
        color: #5555ee;
        background-color: #333333;
        text-decoration: overline;
      }
      .org-code {
        /* org-code */
        color: #b3b3b3;
      }
      .org-date {
        /* org-date */
        color: #a020f0;
        text-decoration: underline;
      }
      .org-document-info {
        /* org-document-info */
        color: #191970;
      }
      .org-document-info-keyword {
        /* org-document-info-keyword */
        color: #b3b3b3;
      }
      .org-document-title {
        /* org-document-title */
        color: #191970;
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        color: #87cefa;
      }
      .org-level-2 {
        /* org-level-2 */
        color: #eedd82;
      }
      .org-link {
        /* org-link */
        color: #00ffff;
        text-decoration: underline;
      }
      .org-meta-line {
        /* org-meta-line */
        color: #ffffff;
        background-color: #8b008b;
      }
      .org-verbatim {
        /* org-verbatim */
        color: #b3b3b3;
      }
      .rainbow-delimiters-depth-1 {
        /* rainbow-delimiters-depth-1-face */
        color: #8c8c8c;
      }
      .rainbow-delimiters-depth-2 {
        /* rainbow-delimiters-depth-2-face */
        color: #93a8c6;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
      .type {
        /* font-lock-type-face */
        color: #98fb98;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #eedd82;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre><code>
<span class="comment">  #  %% This file was generated from <a href="index.org">index.org</a> %% </span>
<span class="org-meta-line">#+STARTUP: showeverything</span>
<span class="org-document-info-keyword">  #+TITLE:</span> <span class="org-document-title">check out my github
</span><span class="org-document-info-keyword">  #+AUTHOR:</span> <span class="org-document-info">Danny McClanahan
</span><span class="org-document-info-keyword">  #+EMAIL:</span> <span class="org-document-info">(format "%s@%s.com" "danieldmcclanahan" "gmail")
</span>
  Press the <span class="org-verbatim">=?=</span> key to see movement and usage commands.

<span class="org-level-1">  * about this site</span>

  This site was generated by <span class="org-link"><a href="#">me</a></span> from static files using <span class="org-link"><a href="https://gnu.org/software/emacs">emacs</a></span> and <span class="org-link"><a href="http://orgmode.org">org-mode</a></span> <span class="rainbow-delimiters-depth-1">(</span>you can see the org source by clicking the "See Org Source" button below<span class="rainbow-delimiters-depth-1">)</span>. The <span class="org-link"><a href="https://github.com/cosmicexplorer/org-site-creator">generator</a></span> is by no means production quality code, but it works pretty reliably and doesn't harvest your personal information <span class="rainbow-delimiters-depth-1">(</span>probably<span class="rainbow-delimiters-depth-1">)</span>. The site supports org-mode's linking features <span class="rainbow-delimiters-depth-1">(</span>here's <span class="org-link"><a href="test.c.html">file:test.c</a></span> from this repo<span class="rainbow-delimiters-depth-1">)</span>, as well as org-babel; here's some inline code:
<span class="org-block-begin-line">  #+BEGIN_SRC javascript
</span>  console.log(<span class="string">"hello world!"</span>);

<span class="keyword">  var</span> <span class="variable-name">a</span> = 3; <span class="comment-delimiter">// </span><span class="comment">set a to 3
</span>
<span class="keyword">  var</span> <span class="variable-name">f</span> = <span class="keyword">function</span>(){
    <span class="constant">this</span>.x = a;
  }

<span class="keyword">  var</span> <span class="variable-name">g</span> = <span class="keyword">new</span> <span class="type">f</span>;
<span class="org-block-end-line">  #+END_SRC
</span>
The highlighting of code blocks runs off <span class="org-link"><a href="https://highlightjs.org">highlight.js</a></span>. It's interesting to note that all these interconnected pages are actually a single page! Such is the magic of <span class="org-link"><a href="https://github.com/cosmicexplorer/org-info-js">org-info.js</a></span> <span class="rainbow-delimiters-depth-1">(</span>which I've sprinkled a little extra pizazz on<span class="rainbow-delimiters-depth-1">)</span>.

Since the site generation is totally static <span class="rainbow-delimiters-depth-1">(</span>the generated site doesn't rely on external resources<span class="rainbow-delimiters-depth-1">)</span>, I'd like to try making it a more generic sort of local documentation generator. But that'll come after I write code that people want documentation for.

<span class="org-level-2">** about me</span>

I'm Danny McClanahan. I <span class="org-link"><a href="https://github.com/cosmicexplorer">write code</a></span> and <span class="org-link"><a href="#">occasionally scribble on the internet</a></span>. I'm an undergraduate at Vanderbilt University and most of my friends think I'm cool; feel free to disagree.

<span class="org-level-1">* posts</span>

I often find that writing about things is harder for me to do than to actually do them, so this is an attempt to combat that. To search through all posts, you can either <span class="org-link"><a href="https://github.com/cosmicexplorer/cosmicexplorer.github.io">clone this repo</a></span> or press the <span class="org-verbatim">=o=</span> key to run occur mode. You can always use your browser's text search tool to search the current post.

<span class="org-level-2">** first thoughts on haskell</span>

<span class="org-date">&lt;2015-08-13&gt;</span>

I don't know haskell, so I'm sailing through <span class="org-link"><a href="http://learnyouahaskell.com">learn you a haskell for great good</a></span> <span class="rainbow-delimiters-depth-1">(</span>which is fantastic<span class="rainbow-delimiters-depth-1">)</span> at a pretty good clip and eventually writing a <span class="org-link"><a href="https://github.com/cosmicexplorer/haskshell">basic shell interpreter</a></span>. I had a few thoughts so I decided to write them down.

- Idiomatic haskell relies on many extremely small, simple, composable functions. On the one hand, this is a good programming practice for most programming languages. On the other hand, this is largely because, unlike lisp, haskell's clean-looking whitespace-heavy syntax makes it extremely difficult to compose functions of any size without extreme application of syntactic sugar <span class="rainbow-delimiters-depth-1">(</span>which also makes it much harder to parse<span class="rainbow-delimiters-depth-1">)</span>.
- Haskell is super hard to parse in your head. The emacs support is fantastic, with extremely rich syntax highlighting; however, I think it would be extremely difficult to parse the syntax in your head without the syntax highlighting. Simpler syntaxes like javascript and lisp can be written without a ton of syntax highlighting extremely easily, and I think haskell by nature is tougher to reason about.
- Curried functions are a cool idea and a great, useful instance of syntactic sugar. Haskell's emphasis on recursion forces most functions into a simple calling style <span class="rainbow-delimiters-depth-1">(</span>higher-order/callback function last<span class="rainbow-delimiters-depth-1">)</span>, which means it's likely the order of the arguments will be correct for currying. However, the syntactic sugar breaks down when the arguments to a function must be switched around; "currying" <span class="rainbow-delimiters-depth-1">(</span>which is just a fancy word for making an anonymous function really easily<span class="rainbow-delimiters-depth-1">)</span> requires manually making a lambda like lisp or javascript.
- Pattern matching is really great. It:
  1. makes a decision tree based on the structure of one or more arguments
  2. assigns values to temporary variables used in a statement
  3. returns a value
  4. does this with an extremely minimal amount of syntax.
- I think a good reader macro could accomplish a similar thing as pattern-matching in lisp. <span class="org-code">~destructuring-bind~</span> is disgustingly verbose and doesn't perform switching. I don't think currying could be implemented as easily, though, outside of a lambda convenience macro.
- Could some forms of pattern matching be performed at compile-time? I suspect not, but I don't like the idea of branching on a pattern match in every iteration of a tight loop, even with tail-recursion.
- Making a language lazy by default in every possible computation is a fantastic idea. I'm not sure I see where it really takes effect yet outside of list recursion <span class="rainbow-delimiters-depth-1">(</span>which many other languages <span class="rainbow-delimiters-depth-2">(</span>C#, js<span class="rainbow-delimiters-depth-2">)</span> have already implemented<span class="rainbow-delimiters-depth-1">)</span>, but it seems cool.
- I tried to understand haskell about a year ago <span class="rainbow-delimiters-depth-1">(</span>which was about a year after I started programming<span class="rainbow-delimiters-depth-1">)</span> and found it hopelessly confusing. After a year of emacs <span class="rainbow-delimiters-depth-1">(</span>with some common lisp here and there<span class="rainbow-delimiters-depth-1">)</span>, I find it extremely easy to understand most of this tutorial, even the "more complex" functional programming parts.
- ghc's error messages are understandable after a bit of practice but unnecessarily cryptic. If it's more useful for compiler writers to have more precise error messages, then they should have a special switch that turns on raw core dumps instead of errors and give regular users some more help.
- If you have to use types in a high-level language <span class="rainbow-delimiters-depth-1">(</span>hint: you don't, although haskell does a pretty good job<span class="rainbow-delimiters-depth-1">)</span>, you need type inference. I didn't believe this before learning haskell, but it would be absolutely impossible to write code without it.
- A lot of the workarounds haskell uses to implement syntactic sugar start showing themselves pretty fast. In particular, moving back and forth between infix and prefix operators and functions requires gross extra punctuation and makes it difficult to quickly scan and reason about code. Obviously it's a learned habit, but there's definitely an efficiency loss to reading code because of that, especially as I find myself constantly turned to and fro between left- and right-associativity.
- Requiring the propagation of nulls through <span class="org-code">~Maybe~</span> to all new computations is a simple and fantastic idea. It moves nullity from being a thing that can just "happen" to a well-understood phenomenon that can be extremely easily controlled, and removed when required. Splitting programs into imperative and non-imperative portions is a very simple analogy; at no point does stateful/imperative/IO/nondeterministic behavior creep into the "pure" process of computation <span class="rainbow-delimiters-depth-1">(</span>outside of random number generators<span class="rainbow-delimiters-depth-1">)</span>. This is very much at odds with almost any other language where basic things like timing errors can require complex error handling. It's extremely easy to see how these concepts arose from an attempt to modernize program correctness proofs <span class="rainbow-delimiters-depth-1">(</span>although it's worth noting haskell only makes proving a program's running time <span class="italic">/more/</span> complex<span class="rainbow-delimiters-depth-1">)</span>.
- The analogy between async computation in javascript/node.js and haskell's <span class="org-code">~IO~</span> impurity propagation is extremely strong. There's no way to get back to synchronous computation in javascript once you've <span class="rainbow-delimiters-depth-1">(</span>hacker voice<span class="rainbow-delimiters-depth-1">)</span> <span class="italic">/gone async/</span> <span class="rainbow-delimiters-depth-1">(</span>at least, until continuations are implemented<span class="rainbow-delimiters-depth-1">)</span>, and you have to continue using asynchronous callbacks to continue processing <span class="rainbow-delimiters-depth-1">(</span>although like haskell, syntactic sugar exists for async computation through ES7's async/await keywords and similar efforts<span class="rainbow-delimiters-depth-1">)</span>. In addition, node.js streams perform the same function as lazy haskell lists, although node streams, to support multiple consumers transparently, are "pushed from behind" instead of "pulled from in front" as haskell's are. While this makes stopping stream input an explicit action instead of implicit the way lazy streams require, it also makes node streams easily able to support both sync and async sources without requiring any special help at all. Having this analogy makes it easier for me to understand the "boxing" and "unboxing" of computation into haskell's IO typeclass in terms of async computations. In fact, all IO in haskell could actually be implemented asynchronously under the hood with no one the wiser, precisely because of the separation between IO- and non IO-bound computation <span class="rainbow-delimiters-depth-1">(</span>or rather, computation and IO<span class="rainbow-delimiters-depth-1">)</span>.
- Not requiring types to declare the functions that act on them creates a very duck-typed feel, which is extremely strange <span class="rainbow-delimiters-depth-1">(</span>and extremely welcome<span class="rainbow-delimiters-depth-1">)</span> in a statically-typed language. It's extremely reminiscent of lisp/js/ruby's approach where classes can be "opened up" after creation.
- Applicative functors and the like make chaining multiple IO operations <span class="rainbow-delimiters-depth-1">(</span>as well as other functor-like operations<span class="rainbow-delimiters-depth-1">)</span> extremely easy, syntax-wise <span class="rainbow-delimiters-depth-1">(</span>although learning all the syntax and jargon is most certainly not easy<span class="rainbow-delimiters-depth-1">)</span>. While the pure/impure split remains, it seems to opaquely mix the two in uncertain ways, making it very easy to be confused about what is happening where. This seems to counteract the goal of separating computation from I/O, although the type system does most of the work to keep that separation anyway.

As a final thought, most of the documentation on any part of haskell becomes extremely dense, extremely fast. Learn You A Haskell was extremely helpful as an introduction, but the wealth of completely new jargon and programming paradigms required to effectively program in haskell makes it difficult to get up to speed with. The entire section on applicative functors is still hazy to me, and I've never had any such difficulty learning other languages. I'm not sure this can really be solved, since its strength is that it wraps so many complex operations and academic successes in syntax sugar to present extremely readable code <span class="rainbow-delimiters-depth-1">(</span>to those who can read it<span class="rainbow-delimiters-depth-1">)</span>.

We'll see how easily this <span class="org-link"><a href="https://github.com/cosmicexplorer/haskshell">shell interpreter</a></span> comes to fruition. I'm extremely impressed that a language can fit so many completely novel <span class="rainbow-delimiters-depth-1">(</span>to me, at least<span class="rainbow-delimiters-depth-1">)</span> constructs in a single package and keep it as streamlined as haskell does. I've finally managed to integrate a haskell environment into my emacs config, so I expect somewhat smooth sailing.

Anchor up?!
</code></pre>
  </body>
</html>
